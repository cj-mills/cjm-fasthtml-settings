"""Configuration loading, saving, and conversion utilities"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../../nbs/core/utils.ipynb.

# %% auto 0
__all__ = ['load_config', 'save_config', 'get_default_values_from_schema', 'get_config_with_defaults',
           'convert_form_data_to_config']

# %% ../../nbs/core/utils.ipynb 3
import json
from pathlib import Path
from typing import Dict, Any, Optional

# %% ../../nbs/core/utils.ipynb 4
# Optional: Import error handling library if available
try:
    from cjm_error_handling.core.base import ErrorContext, ErrorSeverity
    from cjm_error_handling.core.errors import ConfigurationError, ValidationError
    _has_error_handling = True
except ImportError:
    _has_error_handling = False

# %% ../../nbs/core/utils.ipynb 7
def load_config(
    schema_name: str,  # Name of the schema/configuration to load
    config_dir: Optional[Path] = None  # Directory where config files are stored
) -> Dict[str, Any]:  # Loaded configuration dictionary (empty dict if file doesn't exist)
    """Load saved configuration for a schema."""
    if config_dir is None:
        from cjm_fasthtml_settings.core.config import DEFAULT_CONFIG_DIR
        config_dir = DEFAULT_CONFIG_DIR
        
    config_file = Path(config_dir) / f"{schema_name}.json"
    
    if not config_file.exists():
        return {}
    
    try:
        with open(config_file, "r") as f:
            return json.load(f)
    except json.JSONDecodeError as e:
        if _has_error_handling:
            raise ConfigurationError(
                message=f"Failed to parse configuration file: {schema_name}",
                debug_info=f"JSON decode error at line {e.lineno}, column {e.colno}: {e.msg}",
                context=ErrorContext(
                    operation="load_config",
                    extra={"schema_name": schema_name}
                ),
                config_path=str(config_file),
                cause=e
            )
        else:
            print(f"Error parsing config file {config_file}: {e}")
            return {}
    except Exception as e:
        if _has_error_handling:
            raise ConfigurationError(
                message=f"Failed to load configuration: {schema_name}",
                debug_info=f"Error reading config file: {str(e)}",
                context=ErrorContext(
                    operation="load_config",
                    extra={"schema_name": schema_name}
                ),
                config_path=str(config_file),
                cause=e
            )
        else:
            print(f"Error loading config file {config_file}: {e}")
            return {}

# %% ../../nbs/core/utils.ipynb 9
def save_config(
    schema_name: str,  # Name of the schema/configuration to save
    config: Dict[str, Any],  # Configuration dictionary to save
    config_dir: Optional[Path] = None  # Directory where config files are stored
) -> bool:  # True if save succeeded, False otherwise
    """Save configuration for a schema."""
    if config_dir is None:
        from cjm_fasthtml_settings.core.config import DEFAULT_CONFIG_DIR
        config_dir = DEFAULT_CONFIG_DIR
        
    try:
        config_dir = Path(config_dir)
        config_dir.mkdir(exist_ok=True, parents=True)
        
        config_file = config_dir / f"{schema_name}.json"
        with open(config_file, "w") as f:
            json.dump(config, f, indent=2)
        return True
    except PermissionError as e:
        if _has_error_handling:
            raise ConfigurationError(
                message="Permission denied saving configuration",
                debug_info=f"Cannot write to {config_dir}: {str(e)}",
                context=ErrorContext(
                    operation="save_config",
                    extra={"schema_name": schema_name}
                ),
                config_path=str(config_dir / f"{schema_name}.json"),
                cause=e
            )
        else:
            print(f"Permission error saving config: {e}")
            return False
    except Exception as e:
        if _has_error_handling:
            raise ConfigurationError(
                message=f"Failed to save configuration: {schema_name}",
                debug_info=f"Error writing config file: {str(e)}",
                context=ErrorContext(
                    operation="save_config",
                    extra={"schema_name": schema_name}
                ),
                config_path=str(config_dir / f"{schema_name}.json") if config_dir else None,
                cause=e
            )
        else:
            print(f"Error saving config: {e}")
            return False

# %% ../../nbs/core/utils.ipynb 12
def get_default_values_from_schema(
    schema: Dict[str, Any]  # JSON Schema dictionary
) -> Dict[str, Any]:  # Dictionary of default values extracted from schema
    """Extract default values from a JSON schema."""
    values = {}
    properties = schema.get("properties", {})

    for prop_name, prop_schema in properties.items():
        if "default" in prop_schema:
            values[prop_name] = prop_schema["default"]

    return values

# %% ../../nbs/core/utils.ipynb 15
def get_config_with_defaults(
    schema_name: str,  # Name of the schema (or unique_id for grouped schemas)
    schema: Dict[str, Any],  # JSON Schema dictionary
    config_dir: Optional[Path] = None  # Directory where config files are stored
) -> Dict[str, Any]:  # Merged configuration with defaults and saved values
    """Get configuration with defaults merged with saved values."""
    # Use unique_id if present (for grouped schemas), otherwise use schema_name
    config_id = schema.get("unique_id", schema_name)
    
    saved_config = load_config(config_id, config_dir)
    default_values = get_default_values_from_schema(schema)
    return {**default_values, **saved_config}

# %% ../../nbs/core/utils.ipynb 18
def convert_form_data_to_config(
    form_data: dict,  # Raw form data from request
    schema: Dict[str, Any]  # JSON Schema for type conversion
) -> dict:  # Converted configuration dictionary
    """Convert form data to configuration dict based on schema."""
    config = dict(form_data)

    # Handle boolean fields (checkboxes)
    for prop_name, prop_schema in schema.get("properties", {}).items():
        if prop_schema.get("type") == "boolean":
            config[prop_name] = prop_name in config

    # Convert numeric fields
    for prop_name, prop_schema in schema.get("properties", {}).items():
        if prop_name in config:
            prop_type = prop_schema.get("type")
            value = config[prop_name]

            # Handle empty strings - convert to None for optional fields
            if value == "" or value is None:
                config[prop_name] = None
                continue

            if prop_type == "integer" or (isinstance(prop_type, list) and "integer" in prop_type):
                try:
                    config[prop_name] = int(value)
                except (ValueError, TypeError):
                    config[prop_name] = None
            elif prop_type == "number" or (isinstance(prop_type, list) and "number" in prop_type):
                try:
                    config[prop_name] = float(value)
                except (ValueError, TypeError):
                    config[prop_name] = None

    # Handle array fields
    for prop_name, prop_schema in schema.get("properties", {}).items():
        if prop_schema.get("type") == "array" and prop_name in config:
            value = config[prop_name]

            # If it's already a proper list, leave it
            if isinstance(value, list) and value and not isinstance(value[0], str):
                continue

            # If it's a string that looks like a Python list, parse it
            if isinstance(value, str):
                value = value.strip()
                if value.startswith('[') and value.endswith(']'):
                    try:
                        # Safely evaluate the list string
                        import ast
                        config[prop_name] = ast.literal_eval(value)
                    except (ValueError, SyntaxError):
                        # Fall back to comma-separated parsing
                        config[prop_name] = [item.strip() for item in value.split(',') if item.strip()]
                else:
                    # Treat as comma-separated values
                    config[prop_name] = [item.strip() for item in value.split(',') if item.strip()]
            elif isinstance(value, list):
                # If it's a list but contains string representations of lists
                if value and isinstance(value[0], str) and value[0].startswith('['):
                    # Join the parts and parse as a single list
                    joined = ''.join(value)
                    try:
                        import ast
                        config[prop_name] = ast.literal_eval(joined)
                    except (ValueError, SyntaxError):
                        # Keep as is if parsing fails
                        pass
            elif not isinstance(value, list):
                config[prop_name] = [value]

    return config
